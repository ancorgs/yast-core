Boolean.ycp
   The basic datatype YCP_Boolean,
   used as it is, and with operators &&, ||, ! (not)

Builtin.ycp
   Builtin functions of YCP:
       deep quote token
       _dump_definitions()
       comparing two values for equality: operators ==, !=
       is()
       select()
       contains()
       lookup()
       haskey()
       size()
       add()
       symbolof()
       union()
       foreach()
       filter()
       maplist()

Builtin_II.ycp
   Builtin functions of YCP:
       topath()
       substring()

Builtin_III.ycp
   Builtin functions of YCP:
       sort()
       sformat()
       findfirstnotof()
       crypt()

Builtin_IV.ycp
   Builtin functions of YCP:
       toset()
       setcontains()
       tolower()
       toupper()
       toascii()
       flatten()

Comments.ycp
   several types of comments

Compare.ycp
   comparisons, operators are ==, !=, <, >, <=, >=

D_Assign.ycp
   non-terminal assign_stmt, a test coming from language definition

D_DeclTerm.ycp
   non-terminal YPC_DeclTerm, a test coming from language definition

D_DefineTerm.ycp
   non-terminal define_term, a test coming from language definition

D_DoWhile.ycp
   non-terminal do_while, a test coming from language definition
   additionally, continue, break and return are tested

D_Expression.ycp
   non-terminal nb_expression, a test coming from language definition

D_IfThenElse.ycp
   non-terminal if_then_else, a test coming from language definition

D_RepeatUntil.ycp
   non-terminal repeat_until, a test coming from language definition
   the last test case calculates something recursively, that leads
   to an stack overflow on alpha.
   It's not serious, but it's a little bit stressing

D_VarDeclaration.ycp
   non-terminal var_declaration, a test coming from language definition

D_While.ycp
   non-terminal while, a test coming from language definition
   additionally, continue, break and return are tested

Deep_Quote.ycp
   DEEP_QUOTE token

Empty.ycp
   There was empty in the language definition, but no usage
   therefore the test case is also empty ...

Float.ycp
   floats in different representations

FloatExpression.ycp
   some calculations with floats

GlobalSymbols.ycp
   usage of global symbols (first stage, see also Scope.ycp)

IfThenElse1.ycp
IfThenElse2.ycp
IfThenElse3.ycp
IfThenElse4.ycp
   There are four cases, with two independant decisions:
   First, whether the condition is true or false.
   Second, whether the a block or a statement follows.

Integer.ycp
   some calculations with integers
   integers in different representations

Locale.ycp
   locales, (simplier language dependant strings)

Maps.ycp
   some examples of maps

MultilineString.ycp
   Checks if multiline string does not destroy line numbers in log.

Path.ycp
   some example of paths
   concatenation of paths

Precedence.ycp
   operator precedence for operators ==, !=, &&, ||
   the operator precedence controls the sequence of evaluation
   also if brackets are missing ...

Scope.ycp
   also variables with a resticted scope, ie local variables

SingleCharStrings.ycp
   two char combinations of all valid characters

Stress.ycp
   a structure is composed out of simple constructs
   Then the structure is inserted in itself, step by ytep.

StringConcatenation.ycp
   the operator + on strings

StringOverflow.ycp
   a string with 9000 characters, now no problem

Strings.ycp
   valid characters in strings

Ternal.ycp
   ternal operator ? :

ToInteger.ycp
   number conversions to integer

Void.ycp
   The basic datatype YCP_Void

While1.ycp
While2.ycp
   simple while loops
   the second loop is left with break
