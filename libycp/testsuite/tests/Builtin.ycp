
# ---------------------------------------------------------
#
#  Filename:    Builtin.ycp
#
#  Purpose:     test cases for YCP test
#
#  Creator:     jd@suse.de
#
#  Maintainer:  jd@suse.de
#
# ---------------------------------------------------------

# sleep() not tested


// The double backquotes `` are called "deep quote". They are used
// to prevent the enclosed expression from evaluation.

( ``( 1+2 ))
( ``(name) )
( ``{ return 3 + 4; } )
( { return 7; } )
( size (#[deadbeef]) == 4)


// _debug for debugging is no longer tested because the results are now
// logged into a log file.


// Use this for debugging. It will dump a list of all macro
// definitions to stderr.
// furthermore, comparison is tested, see also Compare.ycp
// Compares two values for equality. Returns true, if the are equal.
// Symbols are not equal, if one is quoted and the other not.
// Terms are equal, if their symbols are equal and all arguments are
// pairwise equal.

{
   define comparison ( boolean maximum, integer Int1, integer Int2  )
      ``{
             if( maximum == true )
             {
                 if( Int1 >= Int2 ) return( Int1 );
                 else return ( Int2 );
             }
             else
             {
                 if( Int1 <= Int2 ) return( Int1 );
                 else return ( Int2 );
             }
         };

   define maximum ( integer Int1, integer Int2 )
      ``{
             return( comparison( true, Int1, Int2 ));
         };

   define minimum ( integer Int1, integer Int2 )
      ``{
             return( comparison( false, Int1, Int2 ));
         };

   _dump_scope ();

   return( ( maximum( 5, minimum( 7, 3 )) == 5 ) &&
           ( maximum( 5, 7 ) == maximum( 7, 5 )) &&
           ( minimum( 5, 7 ) == minimum( 7, 5 )));
}


// Compares two values for equality. Returns true, if the are equal.
// Symbols are not equal, if one is quoted and the other not.
// Terms are equal, if their symbols are equal and all arguments are
// pairwise equal.

// libycp[2] Equality on declaration types not yet implemented
// (( ``any == any ) == false )
//(( `any == any ) == false )
//(( any == `any ) == false )
// libycp[2] Equality on declaration types not yet implemented
// (( any == ``any ) == false )
// libycp[2] Equality on declaration types not yet implemented
//(( ``( ``any ) == ``any ) == false )


{
   define comparison ( boolean maximum, integer Int1, integer Int2  )
      ``{
             if( maximum == true )
             {
                 if( Int1 >= Int2 ) return( Int1 );
                 else return ( Int2 );
             }
             else
             {
                 if( Int1 <= Int2 ) return( Int1 );
                 else return ( Int2 );
             }
         };

   define maximum ( integer Int1, integer Int2 )
      ``{
             return( comparison( true, Int1, Int2 ));
         };

   define minimum ( integer Int1, integer Int2 )
      ``{
             return( comparison( false, Int1, Int2 ));
         };

   return( ( maximum( 5, 7 ) != minimum( 5, 7 )) &&
           ( maximum( 7, 5 ) != minimum( 5, 7 )));
}

{
    return( "test cases for define finished" );
}


// structure tests for maps based on select() are no longer valid.
// They are replaced by a comparison which is now valid.

{
     map   node1 = $[ 1: "Austria", 2: "Belgium" ];
     map   node2 = $[ 3: "China", 4: "D-Nation" ];
     map   node3 = $[ 5: "England", 6: "France" ];
     map   node4 = $[ 9: node2, 10: node3 ];
     map   node5 = $[ 8: node1, 11: node4 ];
     map   node6 = $[ 7: "Greece" ];
     map   node7 = $[ 12: node5, 13: node6 ];

     return( node7 == ($[12:$[8:$[1:"Austria", 2:"Belgium"], 11:$[9:$[3:"China", 4:"D-Nation"], 10:$[5:"England", 6:"France"]]], 13:$[7:"Greece"]]));
}

// contains determines, if a certain value is contained in
// a list. Returns true, if this is so.

( contains( [1,2,3], -1 ) == false )
( contains( [1,2,3], 0 ) == false )
( contains( [1,2,3], 2 ))
{
    list  node1 = [ 1, 2 ];
    list  node2 = [ 3, 4 ];
    list  node3 = [ 5, 6 ];
    list  node4 = [ node2, node3 ];
    list  node5 = [ node1, node4 ];
    list  node6 = [ 7 ];
    list  node7 = [ node5, node6 ];

    return( contains( node7, node5 ) == true );
}

{
    list  node1 = [ 1, 2 ];
    list  node2 = [ 3, 4 ];
    list  node3 = [ 5, 6 ];
    list  node4 = [ node2, node3 ];
    list  node5 = [ node1, node4 ];
    list  node6 = [ 7 ];
    list  node7 = [ node5, node6 ];

    return( contains( node7, node1 ) == false );
}

{
    list  node1 = [ 1, 2 ];
    list  node2 = [ 3, 4 ];
    list  node3 = [ 5, 6 ];
    list  node4 = [ node2, node3 ];
    list  node5 = [ node1, node4 ];
    list  node6 = [ 7 ];
    list  node7 = [ node5, node6 ];

    return( node7 );
}

{
    return( "test case contains finished" );
}


// Determines whether the map m contains a pair with the key k.
// Returns true if this is so.

{
     map   MyMap = $[ 0:   "Austria",
                     "1":   "Belgium",
                       2:   "China" ];

    return(  haskey( MyMap, 0 ) &&
             haskey( MyMap, "1" ) &&
             haskey( MyMap, 2 )  &&
           ( haskey( MyMap, false ) == false ) &&
           ( haskey( MyMap, 2.0 ) == false ) &&
           ( haskey( MyMap, "" ) == false ) );
}

{
    return( "test case haskey finished" );
}



// Adds the key/value pair to the map m and returns the newly
// created map. m is not modified. If the key k exists in k, the
// old key/value pair is replaced with the new one.

{
     map   MyMap = $[ 0:   "Austria",
                     "1":   "Belgium",
                       2:   "China" ];

    return( MyMap == ($[0:"Austria", 2:"China",  "1":"Belgium" ]));
}

// two cases deleted: because select is no longer usable with indices

{
     map   MyMap = $[ 0:   "Austria",
                     "1":   "Belgium",
                       2:   "China" ];
     map   NewMap = $[];

//   "one entry within the map is really added (append)"
     NewMap = add( MyMap, 7, "Hungary" );
     return( NewMap == ($[ 0:"Austria", 2:"China", "1":"Belgium", 7:"Hungary"]));
}

// added the replacement

{
     map   MyMap = $[ 0:   "Austria",
                     "1":   "Belgium",
                       2:   "China" ];
     map   NewMap = $[];

//   "one entry within the map is replaced"
     NewMap = add( MyMap, 2, "Estonia" );
     return( NewMap == ($[ 0:"Austria", 2:"Estonia", "1":"Belgium" ]));
}

{
     map   MyMap = $[ 0:   "Austria",
                     "1":   "Belgium",
                       2:   "China" ];
     map   NewMap = $[];

//  "one entry within the map is really added (append) to an empty map"
     MyMap = $[];
     NewMap = add( MyMap, ( "7" ), "Hungary" );
     return( NewMap == ($["7":"Hungary"]));
}

{
    return( "test case add for maps finished" );
}



// Creates a new list that is identical to the list but has
// the value  appended as additional element.

{
     list  MyList = [    "Austria",
                          "Belgium",
                          "China",
                          `D_Nation,
                          "England",
                          "France",
                          "Greece" ];
     list  NewList = [];

     return( MyList );
}

{
     list  MyList = [    "Austria",
                          "Belgium",
                          "China",
                          `D_Nation,
                          "England",
                          "France",
                          "Greece" ];
     list  NewList = [];

//   "one entry within the list is added"
     NewList = add( MyList, .Hungary );
     return( ( size( MyList ) == 7 ) &&
//           ( select( MyList, size( MyList ), nilinteger ) == nil ) &&
             ( select( NewList, size( MyList ), nilpath ) == .Hungary ) );
}

{
     list  MyList = [    "Austria",
                          "Belgium",
                          "China",
                          `D_Nation,
                          "England",
                          "France",
                          "Greece" ];
     list  NewList = [];

//   "one entry is added (append) to an empty list"
     MyList = [];
     NewList = add( MyList, "Hungary" );
     return(
//           ( select( MyList, 0, nil ) == nil ) &&
             ( select( NewList, 0, nilstring ) == "Hungary" ) );
}

{
    return( "test case add for list finished" );
}

// Creates a new list that is identical to the list but has
// the value  prepended as additional element.

{
     list  MyList = [    "Austria",
                          "Belgium",
                          "China",
                          `D_Nation,
                          "England",
                          "France",
                          "Greece" ];
     list  NewList = [];

//   "one entry within the list is added (prepend)"
     NewList = prepend( MyList, .Hungary );
     return( ( size( MyList ) == 7 ) &&
//           ( select( MyList, 0, nil ) == nil ) &&
             ( select( NewList, 0, nilpath ) == .Hungary ) );
}

{
    return( "test case prepend for list finished" );
}


// Creates a new term that is identical to the term  but has
// one more argument .
{
    term  MyTerm = `Termified( `Austria, `Belgium );
    term  NewTerm = `Termified( );

    return( MyTerm );
}

{
    term  MyTerm = `Termified( `Austria, `Belgium );
    term  NewTerm = `Termified( );

//  "one entry within the list is added"
    NewTerm = add( MyTerm, `China );

    return( ( select( MyTerm, 0, nilsymbol ) == `Austria ) &&
            ( select( MyTerm, 1, nilsymbol ) == `Belgium ) &&
//          ( select( MyTerm, size( MyTerm ), nil ) == nil ) &&
            ( select( NewTerm, 0, nilsymbol ) == `Austria ) &&
            ( select( NewTerm, 1, nilsymbol ) == `Belgium ) &&
            ( select( NewTerm, size( MyTerm ), nilsymbol ) == `China ) );
}

{
    term  MyTerm = `Termified( `Austria, `Belgium );
    term  NewTerm = `Termified( );

//  "one entry is added (append) to an empty term"
    MyTerm = `Termified( );
    NewTerm = add( MyTerm, `China );
    NewTerm = add( NewTerm, `China );
    return(
//          ( select( MyTerm, 0, nil ) == nil ) &&
            ( select( NewTerm, 0, nilsymbol ) == `China ) &&
            ( select( NewTerm, 1, nilsymbol ) == `China ) &&
            ( symbolof( MyTerm ) == `Termified )
//       && ( select( NewTerm, 2, nil ) == nil )
          );
}

{
    return( "test case add for term finished" );
}



// Interprets two lists as sets and returns a new list that has
// all elements of the first list and all of the second list. Identical
// elements are dropped. The order of the elements in the new list is
// preserved. Elements of the first list are prior to elements from
// the second list.

{
    list   SetOne = [ 0 , "Hello world", true ];
    list   SetEqual = [ select( SetOne, 2, nil ), 7 * 0, "Hello " + "world" ];
    list   SetTwo = [ ., 15 % 5 ];
    list   SetDifferent = [ 3.00 ];
    list   ResultSet = [];

    ResultSet = union( SetOne, SetOne );
    return( ResultSet == SetOne );
}

{
    list   SetOne = [ 0 , "Hello world", true ];
    list   SetEqual = [ select( SetOne, 2, nil ), 7 * 0, "Hello " + "world" ];
    list   SetTwo = [ ., 15 % 5 ];
    list   SetDifferent = [ 3.00 ];
    list   ResultSet = [];

    ResultSet = union( SetOne, SetEqual );
    return( ( ResultSet == SetOne ) &&
            ( ResultSet != SetEqual ) );
}

{
    list   SetOne = [ 0 , "Hello world", true ];
    list   SetEqual = [ select( SetOne, 2, nil ), 7 * 0, "Hello " + "world" ];
    list   SetTwo = [ ., 15 % 5 ];
    list   SetDifferent = [ 3.00 ];
    list   ResultSet = [];

    ResultSet = union( SetOne, SetTwo );
    return( ResultSet == add( SetOne, select( SetTwo, 0, nil ) ) );
}

{
    list   SetOne = [ 0 , "Hello world", true ];
    list   SetEqual = [ select( SetOne, 2, nil ), 7 * 0, "Hello " + "world" ];
    list   SetTwo = [ ., 15 % 5 ];
    list   SetDifferent = [ 3.00 ];
    list   ResultSet = [];

    ResultSet = union( SetOne, SetDifferent );
    return( ResultSet == add( SetOne, select( SetDifferent, 0, nil ) ) );
}

{
    list   SetOne = [ 0 , "Hello world", true ];
    list   SetEqual = [ select( SetOne, 2, nil ), 7 * 0, "Hello " + "world" ];
    list   SetTwo = [ ., 15 % 5 ];
    list   SetDifferent = [ 3.00 ];
    list   ResultSet = [];

    ResultSet = union( SetDifferent, SetOne );
    return( ResultSet != add( SetOne, select( SetDifferent, 0, nil ) ) );
}

{
    return( "test case union finished" );
}



// Merges two lists.

{
    list l1 = [ "John", "Paul" ];
    list l2 = [ "George", "Ringo" ];

    list r1 = merge (l1, l2);
    list r2 = [ "John", "Paul", "George", "Ringo" ];

    return (r1 == r2);
}

{
    return ("test case merge finished");
}



// some sizes: for list, term and map the size-operator is already tested

( size( . ) == 0 )
( size( ._._._ ) == 3 )
( size( "" ) == 0 )
( size( "Hello World\n Hello World" ) == 24 )


// symbolof() already tested with terms


// For each element of the list the expression
// is executed in a new context, where the variable
// is assigned to that value. The return value of the last execution of
// v is the value of the foreach construct.

{
   any   v = 0;

   return foreach( `v, [ 1, 2, 3 ], ``{ return v; } ) == 3;
}

{
   return foreach( `v, [ 1, 2, 3 ], ``{ return v; } ) == 3;
}

// typed syntax
{
   return foreach(integer v, [ 1, 2, 3 ], ``{ return v; } ) == 3;
}



// For each element of the list l the expression v
// is executed in a new context, where the variable s
// is assigned to that value. If the expression evaluates to true under
// this circumstances, the value is appended to the result list.

{
   return filter( `v, [ 1, 2, 3, 5 ], ``( v > 2 ) ) == [ 3, 5 ];
}

{
   list MyList = [ "Andreas", "Bert", "Charles", "Dean", "Eduard", "Fred" ];

   return filter( `v, MyList, ``( size( v ) > 4 ) ) == [ "Andreas", "Charles", "Eduard" ];
}



// Maps an operation onto all elements of a list and thus creates
// a new list.
// For each element of the list <tt>l</tt> the expression <tt>v</tt>
// is evaluated in a new context, where the variable <tt>s</tt>
// is assigned to that value. The result is the list of those
// evaluations.

{
    return maplist(`v, [1,2,3,5], ``(v + 1)) == [2,3,4,6];
}

