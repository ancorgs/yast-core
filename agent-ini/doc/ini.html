<HTML>
<HEAD>
<TITLE>Ini agent description</TITLE>
<!-- $Id$ -->
</HEAD>
<BODY>
<H1>Ini agent description</H1>
<HR>

<H2>Purpose</H2> 
<P>
Ini agent is common agent to read variety of ini files. Main purpose for this 
agent were configuration files for samba (/etc/samba.conf).
</P>

<h2>Specification</h2>
<font color="red">Texts in red color mean that described feature will be
implemented later. (That means when all non-red features are
implemented.)</font>
<p>
Ini file agent is line-oriented. It means that it reads input line-by-line and
each line is processed separately. If it is required, line may
continue to the next line using \ as the last character of the line. Such lines
are read at once and combined into one string before further processing. 
</p>

<h3>Patterns</h3>
<p>
Lets use regular expressions to find out what kind of line we are processing. We
need regular expression to read and recognize line and a pattern-string
to write anything back to file. Example:<br>
To recognize section beginning we may use:<br>
<tt>	     ^\[\([a-zA-Z0-9\-_]+\)\]</tt><br>
Such section delimiter must start at the first column. Its name may contain
<tt>[a-zA-Z0-9\-_]</tt>. No spaces are allowes. Pattern for write may be:<br>
<tt>	     [%s]</tt><br>
There is no need to \n at the end of pattern. As mentioned above, agent is
line-oriented so it writes \n automaticaly after each line shipped out.<br>
</p>

<h3>Ini file entities</h3>
<p>
Generalized ini file may look like this:<pre>
Comment
Key=Value
Key=Value
Comment
Begin-section-delimiter name
  Key=Value
  Key=Value
  Begin-sub-section-delimiter name
    Key=Value
    Key=Value
  End-sub-section-delimiter name
End-section-delimiter name
</pre>
In most ini files there are no subsections. Classical ini file has no
End-section-delimiter (and therefore it may have no subsections). In most ini
files there are no Key/Values at the top-level. Definitely section name may be
the same as key name. But maybe for some ini files, there may be more keys with
the same name or more sections with the same name.</p>
<p>
Comments in ini files must occupy whole line by default. When they do not we
have a small problem. Should we remove comments at first or process value at
first? Example:<br>
Values must be quoted by " and comments are delimited by #<br> 
Key = "Value    # anything"<br>
How will we understand this? Anyway it is solvable. There will be option that
switches between 3 states:<ul>
<li>(Default) At first, comments are stripped of, then [key, value] are
parsed.</li>
<li>At first, [key, value] then comments are parsed.</li>
<li>Comments may be single on line only.</li></ul>
Note: Comments starting from the beginning of line always have the top
priority.</p>
<p>
There may be Begin-section and End-section delimiter. Section end delimiter is
not mandatory, but when there are no section delimiters, then there are no
nested sections. We must specify, whether nested sections may be used. Default
is: autodetect (which means, subsections are allowed if End-section delimiter is
defined). We must say if toplevel values (not belonging to any section) are
allowed. We might have more types of section delimiters.</p>
<p>
There is only one problem with values. They may be by accident divided to more
lines (without usage of backslash). Then we must detect if this is value that
will continue on the next line. We will restrict this feature only to values
that are quoted.<ul>
  Of course it is possible to detect separated lines also in case no delimiters 
  are used. It would mean to define regexp that detects that current line is not
  continuing line (so it would detect comments, empty lines, key=value pairs and
  section delimiters). But I believe we do not need it.</ul>
</p>
<h3>Configuration file for ini files</h3>
<p>
Example:
<pre>
IniAgent (File Specification,
$[
  "options"  : [ "option1", "option2", ..., $["optionX": "valueX", ... ]],
  "rewrite" : [ [ "regexp", "pattern", ], [ "regexp", "pattern", ], ... ],
  "subindent": "string",
  "comments" : [ "regexp", "regexp", ... ],
  "sections" : [
    $[
      "begin" : [ "regexp", "pattern" ],
      "end"   : [ "regexp", "pattern" ],
    ],
    ...
  ],
  "params" : [
    $[
      "match" :     [ "regexp", "pattern" ],
      "multiline" : [ "regexp", "regexp" ],
    ],
    ...
  ]  
]
</pre>
<h4>File Specification:</h4><p><ul>
<li>"Single file mode": 
In most cases you will specify single file here as a string.</li>
<li>"Multiple files mode": 
If you specify list of file specifications (that may contain wildcards), 
these filenames are used as section names and content is read "into" 
corresponding sections. Please keep in mind, that in this mode you may
create files as well! If you do <tt>Write (.....s.new_section, "#comment\n");</tt>
then when saving new file <tt>new_section</tt> is created. 
</li></ul>
You should use absolute paths or you will have to take extereme care not
to cd in your program :-)
</p>
<h4>Options:</h4><p><ul>
<li>"ignore_case_regexps":
  - case is not significant when processing regexps.</li>
<li>"ignore_case":
  - case is not significant when reading keys/section names.</li>
<li>"first_upper"
  - if `ignore_case, save first letter upper and the other lower in keys and sections</li>
<li>"prefer_uppercase"
  - if `ignore_case, save keys and sections in upper case </li>
<li>"line_can_continue"
  - if line ends with backslash it continues on the next line</li>
<li>"no_nested_sections"
  - nested sections are forbidden and reported as error in log file</li>
<li>"global_values"
  - values at the top level are allowed</li>
<li><font color="red">"repeat_names"
  - there may be more keys with the same name and more sections with the
    same name. Note that sections with the same name as keys are allowed</font>
    </li> 
<li>"comments_last"
  - line is parsed first for single-line comments, then for [key,value] and
    finally for additional comment. This comment is moved above the [key,value]
    pair</li>
<li>"join_multiline"
  - multiline values (parsed by "params":"multiline") are connected into one.</li>
<li>"no_finalcomment_kill"
  - do not kill empty spaces at the end of last comment</li>
<li>"read_only"
  - does not write file at the end</li>
<li>"flat"
  - special mode for files with flat structure -- only values without sections.
  Read/Write/Dir commands work without need to specify what to read (key/section)
  because everything is key.</li>
</ul>
</p>
<h4>rewrite</h4><p>
This list takes in effect only if multiple files are specified. There are rules 
for rewriting file name to section name and pattern back from the section name 
to file name. Example:<pre>
"rewrite" : [
    [ "/etc/sysconfig/network/isdn/(*)$",  "/etc/sysconfig/network/isdn/%s", ],
    [ "/etc/sysconfig/network/modem/(*)$", "/etc/sysconfig/network/modem/%s", ],
],
</pre>
If filename of the processed file matches to the pattern, its first subpattern is 
taken as a section name. When saving the section, filename is created as 
<tt>printf(pattern, section_name)</tt>. First rewrite rule that matches is used 
for file name to section name mapping. If file name doesn't match to any rule
it is let untouched.<br>
Be extremly careful when using rewrite rules. There are 2 possible caveats.
<ul>
<li>Write pattern doesn't correspond to regular expression. In this case you
will have a new file you didn't wish after write.</li>
<li>When creating new top-level section, specify also index of rewrite rule
that should be used for writting the section. If you do not specify it, it
will default to 0, which could be OK but needn't.</li>
</ul>
</p>
<h4>subindent</h4><p>
This string will be added before each line in subsections. If you want to have 
indented subsections, use this. Example: "subindent" : "  ", or "subindent" : "\t".
</p>
<h4>Comments:</h4><p>
List of regular expressions to check. Note that if you combine all expressions
that identify string into one, you will have faster processing. If you allow
comments not starting at the first colunm, you must add "[ \t]*" before comment
regexp. If you want to allow only comments on single line, prepend ^ before
regexp. 
</p>

<h4>Sections:</h4>
There may be more sections defined under key "sections" to allow more types of
section beginnings/ends.<br>
"begin": ["regexp", "pattern"]<br>
  - regexp to find section begin and pattern to write section begin<br>
"end" :  ["regexp", "pattern"]<br>
  - ...<br>
<font color="red">"names" : [list] <br>
  - list of allowed names<br>
  - now list may contain only strings. Maybe it will be enriched to regexps
  too.<br></font>
</p>
<h4>Params:</h4><p>
There may be more types of params defined under key "params" to allow more
types of section beginnings/ends.<br>
"match": ["regexp", "out" ]<br>
  - used to find the key, value line and for output<br>
"multiline" : [ "begin", "end" ]<br>
  - if there may be values spread over more than one line this should define its
    parsing. Please note that main purpose for this are lines broken by accident, 
    for example if some editor breaks longer lines. Example:<pre>
      Key="value value
      still value
      still value"</pre>
    Then begin regexp is: ([^=]+)="([^"]*) and end regexp is ([^"]").
    These are compared at the end so they are the last possibility. But once we
    get into this "divided line" by accident, it becomes greedy, so be carefull
    to forgotten ". 
    If `multiline is not present, this mechanism does not take in effect of
    course.<br>
<font color="red">"names" : [list] <br>
  - list of allowed names<br>
  - now list may contain only strings. Maybe it will be enriched to regexps too.<br></font>
</p>
Format of regexps: glibc regexps will be used. Hence the regexp format must be 
understood by glibc. (try man 7 regex).<br>
Format of pattern: string understood by printf.<br></p>

<h3>Configuration file for sysconfig files (former rc files)</h3>
<p>
Ini agent may be easily used for parsing files in sysconfig directory, but
care must be taken to keep the files clean. No such mess as in rc.config
is allowed. Please do not place bash code into sysconfig files. Only
key="value". Nothing else.<pre>
# comment

.mount.path
`ag_ini(
	SysConfigFile (filename)
)</pre>
SysConfigFile call is just a shortcut to IniAgent call. Equivalent IniAgent
would be:
<pre>
IniAgent ("filename",
    $[
	"options" : [ "line_can_continue", "global_values", "join_multiline", "comments_last", ],
	"comments": [ "^[ \t]*#.*$", "#.*", "^[ \t]*$", ],
	"params" : [
	    $[
	    	"match" : [ "([a-zA-Z0-9_]+)[ \t]*=[ \t]*\"([^\"]*)\"", "%s=\"%s\"" ],
		"multiline" : [ "([a-zA-Z0-9_]+)[ \t]*=[ \t]*\"([^\"]*)", "([^\"]*)\"", ],
	    ],
	    $[
	    	"match" : [ "([a-zA-Z0-9_]+)[ \t]*=[ \t]*([^\"]*[^ \t\"]|)[ \t]*$", "%s=\"%s\"",],
	    ],
	],
])
</pre>

In sysconfig mode, flat mode is used to access values.
</p>
<H2>Implementation</H2>
<pre>
Modes:
  normal
  in-multiline

read line
if comment matches to line
  -- add this line to last comment

if comments-first
  if line contains comment
    -- add comment to last comment
    -- strip comment off the line

if in-multiline mode
  if line matches params::current::multiline[1] (end)
    -- add value to last param-&gt;value
    -- set param-&gt;shipout = 1
  else
    -- add value to last param-&gt;value

else we are in normal mode
  if line matches to section[*]-&gt;begin
    if !in-section
      -- create new sub-section and recursively-call parser
    if in-section && !defined (section[current_section]-&gt;end)
      -- unget line
      return
    if in-section && defined (section[current_section]-&gt;end) && subsections-allowed
      -- create new sub-section and recursively-call parser
    if in-section && defined (section[current_section]-&gt;end) && !subsections-allowed
      -- syntax error
      
  if line matches to section[current_section]-&gt;end
    -- close section and return from recursive function 
    next

  if line matches params[*]::match
    -- add pair key, value
    -- set param-&gt;shipout = 1

  if line matches params[*]::multiline[0]
    -- create pair key, value
    -- set param-&gt;shipout = 0

  if comments-last && contains line, comment
    -- add comment to last comment

  if param-&gt;shipout
    -- add last param to section

</pre>

<I><B>Note:</B> The complete development documentation is available in the
<A HREF="autodocs/index.html"><TT>autodocs/</TT></A> directory.</I>


<H2>Interface for ini-agent</H2>
Assume, agent is mounted on path .ini
<h3>Accessing keys</h3>
<P>Because ini file structure may be hierarchical and there can be sections and
keys with any name, we must use some keyword to distinquish between
key/sections/comments. Paths will look like this:<br>
<table border="1">
<tr><td><tt>.ini.value.<i>sectionname</i>.<i>sectionname</i>.<i>key</i></tt></td>
	<td>identifies value that belongs to key.</td></tr>
<tr><td><tt>.ini.value_comment.<i>sectionname</i>.<i>sectionname</i>.<i>key</i></tt></td>
	<td>identifies comment that belongs to key.</td></tr>
<tr><td><tt>.ini.value_type.<i>sectionname</i>.<i>sectionname</i>.<i>key</i></tt></td>
	<td>identifies type of the key, which is the index of rule this key was read by.</td></tr>
<tr><td><tt>.ini.section.<i>sectionname</i>.<i>sectionname</i></tt></td>
	<td>identifies section key.</td></tr>
<tr><td><tt>.ini.section_comment.<i>sectionname</i>.<i>sectionname</i></tt></td>
	<td>identifies comment that belongs to section key.</td></tr>
<tr><td><tt>.ini.section_type.<i>sectionname</i>.<i>sectionname</i></tt></td>
	<td>identifies type of the section, which is the index of rule this section was read by.</td></tr>
</table>
Abbreviations <tt>v,s,vc,sc,vt,st</tt> are allowed. Imagine what happens if we decide
not to use these prefixed indentifiers. If there is section S1 with subsection
comment, then we would not know what .ini.S1.comment means. <br>
These paths work with <b>Read</b> and <b>Dir</b>. <b>Write</b> is a special
case. You may write new values and their comments. You may write new 
sections and their comments. But when you write section, section name 
is encoded in path, so parameter passed to <b>Write</b> is always 
understood as comment.<br>
All Reads return strings. All Writes expect strings or nil as parameter. 
If nil is passed to Write, value or section is removed. All Dirs return 
list of strings.<br>
In write, only strings can be section names and only strings or integers may
be values. Integers are converted to strings when writting and are read back
as strings.<br>
If Write is requested to write (create) key or section on non-existing path,
the sections on path are created (like in recursive mkdir).
</p>
<h3>SysConfig/flat mode</h3>
<p>
This mode is used for reading sysconfig-files and is compatibile with rc-agent. 
So values are accessible under <tt>.ini.<i>key</i></tt> and their comments are
accessible under <tt>.ini.<i>key</i>.comment</tt>. Value may be removed by storing
<tt>nil</tt> into it. If you specify unexisting key when writting value,
new value will be created. You may not create value by writting its comment.
</p>
<h3>Final write</h3>
<p>
Changes are written to disk when Write (.ini, nil) is called or in agent
destructor. Agent handles external change of ini file, in other words, 
it writes only changed values. If you do not call Write at the end, agent 
writes changed data to disk in the destructor.<br>
By default file is written only if something changed. File may be 
forced to be written by calling <tt>Write (.ini, "force");</tt><br>
If you do not want agent to write changed data, call 
<tt>Write (.ini, "clean");</tt>. It will set dirty flag to false. Use with 
care! It does not revert data to their original values! Most save is using 
it just before leaving module (and destroying the agent).<br>
When write is unable to open some file for writting, it returns false. True 
is returned otherwise.
</p>
<p>
<h2>TODO</h2>
I am going to implement following features when someone requests them.
I do not want to fill the agent with features that will be never used.<br>
<h3>Flag repeat_names</h3>
This apparently requests new aproach to keys/sections storing and 
accessing. I doubt we will need it and I would prefere if it would
be solved by separate agent if needed. I want to keep this simple as it
is now.
<h3>Allowed section names and key names</h3>
There can be list of allowed names for sections/keys. No problem to implement, 
just tell if you need it. But do you really need it?
<h3>Browser</h3>
There could be some Read function that would return structure that could 
be passed to tree widget. It is really the fastest way to create it in C++
but I am not sure if it is possible to do it enough versatile. Another 
problem is with changes. 
<h3>Re-ordering</h3>
We should be able to change order of values/sections.
<h3>Section renaming</h3>
We should be able to rename section. Easy to implement. Does anybody need
it?
<h3>I am the highest authority!</h3>
Client should be able to tell agent not to re-read externally changed file.
Sometimes, when client completly re-creates file, its re-read could cause
big mess.
</p>
<P>
<h2>Examples</h2>
Each features should be tested in testsuite. Look for an inspiration there.
Here are some most common or interesting examples:<br>
<h3>Dialup providers (package providers)</h3><pre>
.ini

`ag_ini(
  IniAgent( [ "/usr/share/providers/*.wvdial.conf" ],
    $[
      "options" : [ "read_only" ],
      "comments": [ "^[ \t]*#.*", "^[ \t]*$" ],
      "sections" : [
        $[
        "begin" : [ "[ \t]*\\[Dialer[ \t]+(.*[^ \t])[ \t]*\\][ \t]*", "[Dialer %s]"        ],
      ],
      "params" : [
        $[
        "match" : [ "^[ \t]*([^=]*[^ \t=])[ \t]*=[ \t]*(.*[^ \t]|)[ \t]*$" , "%s =       ],
    ],
    ]
  )
)
</pre>
<h3>smb.conf</h3><pre>
.ini

`ag_ini(
  IniAgent("/etc/smb.conf",
    $[
      "options" : [ "no_nested_sections", "ignore_case",
                    "line_can_continue", 
                ],
      "comments": [ "^[ \t]*;.*", ";.*", "^[ \t]*$" ],
      "sections" : [
        $[
        "begin" : [ "[ \t]*\\[[ \t]*(.*[^ \t])[ \t]*\\][ \t]*", "[%s]" ],
        ],
      ],
      "params" : [
        $[
        "match" : [ "^[ \t]*([^=]*[^ \t=])[ \t]*=[ \t]*(.*[^ \t]|)[ \t]*$" , "   %s = %s"],
      ],
    ],
    ]
  )
)
</pre>
<h3>/etc/lilo.conf</h3>
<pre>
.ini

`ag_ini(
  IniAgent("/tmp/lilo.conf",
    $[
      "options" : [ "no_nested_sections", "ignore_case",
                "global_values",
                ],
      "subindent" : "  ",
      "comments": [ "^[ \t]*#.*", "#.*", "^[ \t]*$" ],
      "sections" : [
        $[
        "begin" : [ "other[ \t]*=[\t ]*(.*[^ \t])[ \t]*$", "  other\t= %s" ],
        ],
        $[
        "begin" : [ "image[ \t]*=[\t ]*(.*[^ \t])[ \t]*$", "  image\t= %s" ],
        ],
      ],
      "params" : [
        $[
        "match" : [ "^[ \t]*([^=]*[^ \t=])[ \t]*=[ \t]*(.*[^ \t]|)[ \t]*$" , "%s = %s"],
        ],
        $[
        "match" : [ "^[ \t]*([^=]*[^ \t=])()*$" , "%s"],
        ],
    ],
    ]
  )
)
</pre>
<h3>Rewrite rules</h3>
See testsuites, <tt>multi/rewrite*</tt>. <font color="red">FIXME: insert an example here.</font>
</p>
<p>
<h2>Changes</h2>
<ul>
<li><b>2001/10/09:</b> Forced final write changed from Write (.ini.write_force, nil) to Write (.ini, "force").</li>
<li><b>2001/10/09:</b> RcAgent interface described.</li>
<li><b>2002/01/09:</b> Write (.ini, "clean") to clean changes implemented and described.</li>
<li><b>2002/01/09:</b> When writtig new value or section, non existing sections on path are created.</li>
<li><b>2002/01/15:</b> RcFile replaced by SysConfigFile. Functionality changed too.</li>
</ul>
</p>
<P>
<ADDRESS>
Petr Blahos &lt;pblahos@suse.cz&gt;<BR>
</ADDRESS>
</p>
</BODY>
</HTML>
